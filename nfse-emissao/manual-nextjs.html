<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manual Next.js + TypeScript do Projeto NFSe</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #101827;
      --muted: #9aa4b2;
      --text: #e5e7eb;
      --brand: #22c55e;
      --accent: #3b82f6;
      --danger: #ef4444;
      --code-bg: #0f172a;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .layout { display: grid; grid-template-columns: 320px 1fr; min-height: 100vh; }
    nav { background: var(--panel); border-right: 1px solid var(--border); padding: 24px; position: sticky; top: 0; height: 100vh; overflow-y: auto; }
    main { padding: 32px; }
    h1 { font-size: 28px; margin: 0 0 16px 0; }
    h2 { font-size: 22px; margin: 32px 0 12px; color: #fff; }
    h3 { font-size: 18px; margin: 24px 0 10px; color: #fff; }
    p { color: var(--text); line-height: 1.6; }
    .muted { color: var(--muted); }
    .toc h2 { font-size: 16px; margin: 0 0 8px; color: var(--muted); }
    .toc a { display: block; padding: 6px 8px; border-radius: 8px; color: var(--text); }
    .toc a:hover { background: #0b1730; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin: 16px 0; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 13px; }
    pre { background: var(--code-bg); color: #cbd5e1; border-radius: 10px; padding: 14px; overflow: auto; border: 1px solid var(--border); white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere; }
    kbd { background: #111827; padding: 2px 6px; border: 1px solid #374151; border-radius: 6px; font-size: 12px; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; background: #0b1730; border: 1px solid #1f2a44; color: #9ab4ff; }
    .level { display:inline-block; margin-left:8px; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border); vertical-align: middle; }
    .level-basic { background:#0b1730; color:#93c5fd; }
    .level-intermediate { background:#1a263d; color:#fde68a; }
    .level-advanced { background:#2a1420; color:#fca5a5; }
    .level-all { background:#111827; color:#cbd5e1; }
    .ok { color: var(--brand); }
    .warn { color: #f59e0b; }
    .err { color: var(--danger); }
    ul { margin: 8px 0 8px 18px; }
    li { margin: 4px 0; }
    .two-col { display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 1100px) { .two-col { grid-template-columns: 1fr 1fr; } }
    /* Melhorias de quebra para evitar cortes de texto */
    main, .card, p, li { overflow-wrap: anywhere; word-break: break-word; }
    /* Responsividade: colapsar sidebar no mobile e exibir botão de sumário */
    .toc-toggle { display: none; }
    html { scroll-behavior: smooth; }
    nav { -webkit-overflow-scrolling: touch; }
    @media (max-width: 1024px) {
      .layout { grid-template-columns: 1fr; }
      nav { position: static; height: auto; max-height: none; overflow: visible; border-right: none; border-bottom: 1px solid var(--border); }
      .toc-toggle { display: flex; position: sticky; top: 0; z-index: 50; background: var(--panel); border-bottom: 1px solid var(--border); padding: 12px 16px; align-items: center; gap: 8px; }
      #toc { display: none; }
      nav.toc-open #toc { display: block; }
      pre { font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <nav id="sideNav">
      <h1>Manual Next.js + TypeScript</h1>
      <p class="muted">Baseado no código e padrões do sistema NFSe.</p>
      <div class="toc" id="toc">
        <h2>Sumário</h2>
        <a href="#conceitos">Conceitos fundamentais</a>
        <a href="#react-do-zero">Front-end React do Zero (Prático e Responsivo)</a>
        <a href="#typescript-basico">TypeScript básico</a>
        <a href="#react-basico">React no projeto</a>
        <a href="#estilizacao-ui">Estilização e UI</a>
        <a href="#programacao-reativa">Programação Reativa e Como o React Funciona</a>
        <a href="#vb6-vs-react">Exemplos lado a lado: VB6 vs React</a>
        <a href="#guia-vb6-react">Guia de Referência Rápida: VB6 → React</a>
        <a href="#typescript-intermediario">TypeScript intermediário</a>
        <a href="#nextjs-app">Next.js (App Router)</a>
        <a href="#estado-contexto">Estado global e Context</a>
        <a href="#api-routes">APIs do Next.js</a>
        <a href="#hooks-avancados">Hooks avançados: useReducer, useMemo e useCallback</a>
        <a href="#auth-jwt">Autenticação e JWT</a>
        <a href="#prisma-db">Prisma e Banco de Dados</a>
        <a href="#arquitetura-nfse">Arquitetura NFSe (local)</a>
        <a href="#tests">Testes (Cypress)</a>
        <a href="#boas-praticas">Boas práticas e clean code</a>
        <a href="#troubleshooting">Troubleshooting</a>
        <a href="#projetos-praticos">Projetos práticos guiados</a>
        <a href="#trilha">Trilha de Aprendizagem (Zero → Avançado)</a>
        <a href="#referencias">Referências</a>
      </div>
    </nav>
    <main>
      <div class="toc-toggle">
        <button type="button" id="tocBtn" style="display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border:1px solid var(--border);border-radius:8px;background:#0b1730;color:#e5e7eb;cursor:pointer">
          ☰ Sumário
        </button>
        <span class="muted">Navegue pelos tópicos</span>
      </div>
      <section id="conceitos">
        <h2>1. Conceitos fundamentais <span class="level level-all">Todos</span></h2>
        <div class="card">
          <p>Este manual foi escrito para você dar manutenção e evoluir o sistema seguindo os padrões existentes. O projeto utiliza <span class="tag">TypeScript</span>, <span class="tag">React</span> e <span class="tag">Next.js (App Router)</span>, com <span class="tag">Prisma</span> (MySQL), autenticação por <span class="tag">JWT</span>, componentes UI com <span class="tag">Tailwind</span> e <span class="tag">Ant Design</span>, e testes de interface com <span class="tag">Cypress</span>.</p>
          <ul>
            <li><b>Linguagem:</b> TypeScript (tipado, UTF-8).</li>
            <li><b>Padrões:</b> Clean Code, componentes funcionais, hooks, Context API.</li>
            <li><b>Estratégias:</b> APIs internas via Next, autenticação via cookies/token, ORM Prisma.</li>
          </ul>
        </div>
      </section>
      <section id="hooks-avancados">
        <h2>Hooks avançados: useReducer, useMemo e useCallback <span class="level level-intermediate">Intermediário</span></h2>
        <div class="two-col">
          <div class="card">
            <h3>useReducer (estado complexo com ações)</h3>
            <p class="muted">Útil quando o estado tem múltiplos campos/regras. Centraliza a lógica em um reducer.</p>
            <pre><code>type Acao = { type: "inc" } | { type: "dec" } | { type: "set"; valor: number };
function reducer(estado: number, acao: Acao) {
  switch (acao.type) {
    case "inc": return estado + 1;
    case "dec": return Math.max(0, estado - 1);
    case "set": return acao.valor;
  }
}

export function ContadorReducer() {
  const [valor, dispatch] = useReducer(reducer, 0);
  return (
    &lt;div className="flex items-center gap-2"&gt;
      &lt;button onClick={() =&gt; dispatch({ type: "dec" })} className="px-2 border"&gt;-&lt;/button&gt;
      &lt;span&gt;{valor}&lt;/span&gt;
      &lt;button onClick={() =&gt; dispatch({ type: "inc" })} className="px-2 border"&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
          </div>
          <div class="card">
            <h3>useMemo (valores derivados custosos)</h3>
            <p class="muted">Evita recomputações caras quando as dependências não mudam.</p>
            <pre><code>export function ListaPesada({ itens }: { itens: number[] }) {
  const soma = useMemo(() =&gt; {
    // simular custo: reduzir array grande
    return itens.reduce((acc, n) =&gt; acc + n, 0);
  }, [itens]);
  return &lt;div&gt;Soma: {soma}&lt;/div&gt;;
}

// Também útil para memoizar listas filtradas/ordenadas
const filtrados = useMemo(() =&gt; itens.filter(x =&gt; x &gt; 0).sort(), [itens]);
</code></pre>
          </div>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>useCallback (funções estáveis para passar a filhos)</h3>
            <p class="muted">Evita recriar handlers a cada render quando usados como props em componentes memorizados.</p>
            <pre><code>type ItemProps = { id: number; onRemover: (id: number) =&gt; void };
const Item = React.memo(function Item({ id, onRemover }: ItemProps) {
  return &lt;button onClick={() =&gt; onRemover(id)} className="border px-2"&gt;Remover {id}&lt;/button&gt;;
});

export function ListaComCallback({ ids }: { ids: number[] }) {
  const [lista, setLista] = useState(ids);
  const remover = useCallback((id: number) =&gt; {
    setLista(l =&gt; l.filter(x =&gt; x !== id));
  }, []);
  return &lt;div className="flex gap-2 flex-wrap"&gt;{lista.map(i =&gt; &lt;Item key={i} id={i} onRemover={remover} /&gt;)}&lt;/div&gt;;
}
</code></pre>
          </div>
          <div class="card">
            <h3>Quando usar</h3>
            <ul>
              <li><b>useReducer</b>: estados com múltiplos campos/regra, ações claras.</li>
              <li><b>useMemo</b>: cálculos caros/derivados, listas filtradas/ordenadas.</li>
              <li><b>useCallback</b>: handlers passados a filhos memorizados (React.memo).</li>
            </ul>
          </div>
        </div>
        <div class="card">
          <h3>Mini-exercícios</h3>
          <ol>
            <li><b>Reducer de formulário</b>: controlar nome/email/aceiteTermos com ações set_nome, set_email, toggle_termos e limpar.</li>
            <li><b>Lista derivada</b>: dada uma lista grande, memoizar filtro e ordenação e exibir contagem.</li>
            <li><b>Callback estável</b>: passar onSelect para itens memorizados e evitar re-render desnecessário.</li>
          </ol>
        </div>
      </section>

      

      <section id="guia-vb6-react">
        <h2>Guia de Referência Rápida: VB6 → React <span class="level level-all">Todos</span></h2>
        <div class="two-col">
          <div class="card">
            <h3>Eventos e ciclo de vida</h3>
            <ul>
              <li><b>VB6:</b> Form_Load → código ao abrir a tela.</li>
              <li><b>React:</b> useEffect(() ⇒ { ... }, []) para rodar uma vez ao montar.</li>
              <li><b>VB6:</b> Control_Click, Change, etc.</li>
              <li><b>React:</b> onClick, onChange em JSX; atualize estado (setState).</li>
            </ul>
          </div>
          <div class="card">
            <h3>Estado e dados</h3>
            <ul>
              <li><b>VB6:</b> propriedades dos controles (Text, Checked) são o “estado”.</li>
              <li><b>React:</b> estado controlado via useState/useReducer; inputs refletem o estado.</li>
              <li><b>Compartilhar estado:</b> Context em vez de variáveis globais.</li>
            </ul>
          </div>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>Binding e listas</h3>
            <ul>
              <li><b>VB6:</b> AddItem/RemoveItem no ListBox.</li>
              <li><b>React:</b> map() no JSX com key única; filtro/ordenar com estado.</li>
              <li><b>Atualização:</b> imutável (copiar array/objeto) antes de setar estado.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Dados externos</h3>
            <ul>
              <li><b>VB6:</b> ADO/DAO ou componentes de dados.</li>
              <li><b>React/Next:</b> fetch/axios em useEffect; Next API Routes para backend local.</li>
              <li><b>Erro/Loading:</b> estados específicos com mensagens e skeletons.</li>
            </ul>
          </div>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>Validação e UX</h3>
            <ul>
              <li>Inputs controlados + mensagens claras (AntD message/Modal quando necessário).</li>
              <li>Evite bloquear a UI; prefira feedbacks e estados de carregamento.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Arquitetura</h3>
            <ul>
              <li>Separe: componentes de UI, serviços (fetch), Context (estado global), API (Next), DB (Prisma).</li>
              <li>Clean code: funções curtas, nomes claros, tipagem forte.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="vb6-vs-react">
        <h2>Exemplos lado a lado: VB6 vs React <span class="level level-all">Todos</span></h2>
        <div class="card">
          <h3>1) Campo de texto (atualização e exibição)</h3>
          <div class="two-col">
            <div class="card">
              <h3 class="muted">VB6 (imperativo)</h3>
              <pre><code>' Em um Form com TextBox1 e Label1
Private Sub TextBox1_Change()
  Label1.Caption = TextBox1.Text
End Sub
</code></pre>
            </div>
            <div class="card">
              <h3 class="muted">React (declarativo)</h3>
              <pre><code>import { useState } from "react";

export function EcoTexto() {
  const [texto, setTexto] = useState("");
  return (
    &lt;div className="space-y-2"&gt;
      &lt;input value={texto} onChange={e =&gt; setTexto(e.target.value)} className="border p-2 w-full" /&gt;
      &lt;div&gt;{texto}&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
            </div>
          </div>
        </div>

        <div class="card">
          <h3>2) Lista com filtro (bind e filtragem)</h3>
          <div class="two-col">
            <div class="card">
              <h3 class="muted">VB6 (imperativo)</h3>
              <pre><code>' ListBox1, TextBoxBusca
Private Sub TextBoxBusca_Change()
  ListBox1.Clear
  For i = 0 To UBound(Produtos)
    If InStr(1, Produtos(i).Nome, TextBoxBusca.Text, vbTextCompare) &gt; 0 Then
      ListBox1.AddItem Produtos(i).Nome
    End If
  Next i
End Sub
</code></pre>
            </div>
            <div class="card">
              <h3 class="muted">React (declarativo)</h3>
              <pre><code>const PRODUTOS = [
  { id: 1, nome: "Teclado" },
  { id: 2, nome: "Mouse" },
  { id: 3, nome: "Monitor" },
];

export function ListaComFiltro() {
  const [q, setQ] = useState("");
  const filtrados = PRODUTOS.filter(p =&gt; p.nome.toLowerCase().includes(q.toLowerCase()));
  return (
    &lt;div className="space-y-2"&gt;
      &lt;input value={q} onChange={e =&gt; setQ(e.target.value)} className="border p-2 w-full" placeholder="Buscar" /&gt;
      &lt;ul className="list-disc pl-5"&gt;
        {filtrados.map(p =&gt; &lt;li key={p.id}&gt;{p.nome}&lt;/li&gt;)}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</code></pre>
            </div>
          </div>
        </div>

        <div class="card">
          <h3>3) Formulário com validação</h3>
          <div class="two-col">
            <div class="card">
              <h3 class="muted">VB6 (imperativo)</h3>
              <pre><code>' TextBoxNome, Command1
Private Sub Command1_Click()
  If Len(Trim(TextBoxNome.Text)) = 0 Then
    MsgBox "Nome é obrigatório"
    Exit Sub
  End If
  ' Salvar e limpar
  TextBoxNome.Text = ""
End Sub
</code></pre>
            </div>
            <div class="card">
              <h3 class="muted">React (declarativo)</h3>
              <pre><code>export function FormValidacao() {
  const [nome, setNome] = useState("");
  const [erro, setErro] = useState&lt;string | null&gt;(null);
  function salvar(e: React.FormEvent) {
    e.preventDefault();
    if (!nome.trim()) { setErro("Nome é obrigatório"); return; }
    setErro(null);
    // Salvar...
    setNome("");
  }
  return (
    &lt;form onSubmit={salvar} className="space-y-2"&gt;
      &lt;input value={nome} onChange={e =&gt; setNome(e.target.value)} className="border p-2 w-full" placeholder="Nome" /&gt;
      {erro &amp;&amp; &lt;div className="text-red-400"&gt;{erro}&lt;/div&gt;}
      &lt;button className="bg-blue-600 text-white px-3 py-1 rounded"&gt;Salvar&lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
            </div>
          </div>
        </div>
      </section>

      <section id="programacao-reativa">
        <h2>Programação Reativa e Como o React Funciona <span class="level level-all">Todos</span></h2>
        <div class="card">
          <h3>História resumida do React</h3>
          <ul>
            <li>2013: criado pelo Facebook para resolver interfaces complexas com alto volume de atualizações.</li>
            <li>Ideia central: <b>UI declarativa</b> + <b>Virtual DOM</b> para atualizar a tela de forma eficiente.</li>
            <li>Evolução: componentes funcionais, <b>Hooks</b> (2019), <b>Concurrent Rendering</b> e melhorias de performance.</li>
          </ul>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>Programação reativa na prática (no React)</h3>
            <ul>
              <li><b>Estado → UI</b>: a interface é função do estado. Mudar o estado dispara re-render.</li>
              <li><b>Imutabilidade</b>: crie novos objetos/arrays ao atualizar (ex.: <code>setX([...x, novo])</code>).</li>
              <li><b>Fluxo unidirecional</b>: dados descem por props; eventos sobem via callbacks.</li>
              <li><b>Renderização declarativa</b>: você descreve “o que” renderizar, não “como” atualizar manualmente.</li>
              <li><b>Efeitos colaterais</b>: encapsule com <code>useEffect</code> (assinaturas, timers, fetch, listeners).</li>
            </ul>
          </div>
          <div class="card">
            <h3>Como o React atualiza a tela</h3>
            <ul>
              <li><b>Virtual DOM</b>: representação leve da UI em memória.</li>
              <li><b>Reconciliação (diff)</b>: compara VDOM anterior e novo para aplicar somente o necessário no DOM real.</li>
              <li><b>Chaves (keys)</b>: ajudam o React a identificar itens de listas para atualizar/mover/remover corretamente.</li>
              <li><b>Batching</b>: múltiplos <code>setState</code> podem ser agrupados para menos re-renderizações.</li>
              <li><b>React 18</b>: melhorias de concorrência e responsividade em atualizações.
            </ul>
          </div>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>Comparação direta: VB6 x React</h3>
            <ul>
              <li><b>VB6</b>: orientado a formulários/controles; alterações imperativas no UI (ex.: <i>TextBox.Text = "..."</i>).</li>
              <li><b>React</b>: declarativo; você muda o <b>estado</b> e o React reflete isso no UI automaticamente.</li>
              <li><b>VB6</b>: estado geralmente mutável e espalhado nos controles.</li>
              <li><b>React</b>: estado local/controlado e, quando necessário, <b>Context</b> para compartilhar entre componentes.</li>
              <li><b>VB6</b>: eventos por controle; UI “puxa” a lógica.</li>
              <li><b>React</b>: componentes pequenos e previsíveis; UI “reflete” estado + props.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Dicas de migração mental para quem vem do VB6</h3>
            <ul>
              <li>Pense a tela como função do estado: <b>UI = f(estado)</b>.</li>
              <li>Evite alterar a DOM diretamente; use estado/props e deixe o React atualizar.</li>
              <li>Quebre telas grandes em <b>componentes</b> menores e reutilizáveis.</li>
              <li>Controle os inputs via estado; valide e mostre feedback ao digitar.</li>
              <li>Prefira <b>imutabilidade</b> e <b>tipagem</b> (TypeScript) para evitar bugs sutis.</li>
            </ul>
          </div>
        </div>
        <div class="card">
          <h3>Glossário rápido</h3>
          <ul>
            <li><b>Componente</b>: função que recebe props e retorna JSX (UI declarativa).</li>
            <li><b>Estado</b>: dados internos do componente que mudam com o tempo (<code>useState</code>).</li>
            <li><b>Efeito</b>: código que roda por fora do render (ex.: <code>useEffect</code> para fetch).</li>
            <li><b>Props</b>: dados de entrada do componente (somente leitura).</li>
            <li><b>Context</b>: compartilha estado/dados com a árvore de componentes sem “repasse” manual.</li>
          </ul>
        </div>
      </section>

      <section id="trilha">
        <h2>2. Trilha de Aprendizagem (Zero → Avançado) <span class="level level-all">Todos</span></h2>
        <div class="card">
          <h3>Etapas sugeridas</h3>
          <ol>
            <li><b>Fundamentos</b>: Leia “TypeScript básico” e “React no projeto”. Pratique tipos, props e estado.</li>
            <li><b>Intermediário</b>: Estude “TypeScript intermediário” (generics/utilitários) e “Estilização e UI”.</li>
            <li><b>Next.js</b>: Veja “Next.js (App Router)”, rotas, client/server components e navegação.</li>
            <li><b>Estado Global</b>: Aprofunde em “Estado global e Context” e padrões usados no projeto.</li>
            <li><b>APIs</b>: Pratique “APIs do Next.js”, validação e tratamento de erros.</li>
            <li><b>Autenticação</b>: Leia “Autenticação e JWT” e entenda middleware/segurança.</li>
            <li><b>Banco de Dados</b>: “Prisma e Banco de Dados”, modelos, consultas e migrações.</li>
            <li><b>Domínio NFSe</b>: “Arquitetura NFSe”, XML, assinatura e compactação.</li>
            <li><b>Qualidade</b>: “Testes (Cypress)” e “Boas práticas”. Use o checklist de revisão.</li>
          </ol>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>Mapa de leitura</h3>
            <ul>
              <li>Comece pelo React do Zero e TypeScript básico.</li>
              <li>Avance para App Router, Context e APIs.</li>
              <li>Finalize com Prisma, Autenticação e NFSe.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Competências ao final</h3>
            <ul>
              <li>Montar telas responsivas com componentes reutilizáveis.</li>
              <li>Consumir e criar APIs internas do Next.js.</li>
              <li>Persistir dados com Prisma e aplicar autenticação com JWT.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="typescript-basico">
        <h2>2. TypeScript básico <span class="level level-basic">Básico</span></h2>
        <div class="two-col">
          <div class="card">
            <h3>Tipos de variáveis</h3>
            <pre><code>// Primitivos
let nome: string = "Ana";
let idade: number = 28;
let ativo: boolean = true;
let nada: null = null;
let indefinido: undefined = undefined;

// Arrays e Tuplas
let notas: number[] = [7.5, 8.0, 9.2];
let par: [string, number] = ["codigo", 123];

// Objetos
type Usuario = { id: number; nome: string; admin?: boolean };
const u: Usuario = { id: 1, nome: "Ana" };

// Union e Literal
let estado: "ativo" | "inativo" = "ativo";
let id: number | string = "42";
</code></pre>
          </div>
          <div class="card">
            <h3>Funções e parâmetros</h3>
            <pre><code>// Declaração de função
function somar(a: number, b: number): number { return a + b; }

// Arrow function
const mult = (a: number, b: number): number => a * b;

// Parâmetros opcionais e default
type BuscarParams = { termo?: string; limite?: number };
function buscar(p: BuscarParams = {}): string[] { return []; }

// Narrowing (refinando tipos)
function formatId(id: number | string) {
  if (typeof id === "number") return id.toString();
  return id;
}
</code></pre>
          </div>
        </div>
        <div class="card">
          <h3>Interfaces, Types e Enums</h3>
          <pre><code>interface Prestador { id: number; nome: string; ativo: boolean }

type PrestadorDTO = Pick&lt;Prestador, "nome" | "ativo"&gt;;

enum Ambiente { Producao = 1, Homologacao = 2 }

const a: Ambiente = Ambiente.Producao;
</code></pre>
        </div>
      </section>

      <section id="typescript-intermediario">
        <h2>3. TypeScript intermediário <span class="level level-intermediate">Intermediário</span></h2>
        <div class="two-col">
          <div class="card">
            <h3>Generics</h3>
            <pre><code>function wrap&lt;T&gt;(value: T) { return { value }; }
const w = wrap&lt;string&gt;("ok");

interface ApiResult&lt;T&gt; { data: T; error?: string }
</code></pre>
          </div>
          <div class="card">
            <h3>Utilitários úteis</h3>
            <pre><code>type SomenteLeitura = Readonly&lt;{ nome: string; idade: number }&gt;;

type ParcialPrestador = Partial&lt;Prestador&gt;;

type Obrigatorio = Required&lt;{ a?: number }&gt;;

type ApenasNome = Pick&lt;Prestador, "nome"&gt;;

type SemId = Omit&lt;Prestador, "id"&gt;;
</code></pre>
          </div>
        </div>
        <div class="card">
          <h3>Tratamento de erros</h3>
          <pre><code>try {
  // ...
} catch (e: unknown) {
  const msg = e instanceof Error ? e.message : String(e);
}
</code></pre>
        </div>
      </section>

      <section id="react-basico">
        <h2>4. React no projeto <span class="level level-basic">Básico</span></h2>
        <div class="two-col">
          <div class="card">
            <h3>Componentes e Props</h3>
            <pre><code>type BotaoProps = { titulo: string; onClick?: () =&gt; void };
export function Botao({ titulo, onClick }: BotaoProps) {
  return &lt;button onClick={onClick}&gt;{titulo}&lt;/button&gt;;
}
</code></pre>
            <p class="muted">Use componentes funcionais e tipagem de props. Evite <i>any</i>.</p>
          </div>
          <div class="card">
            <h3>Estado e Efeitos</h3>
            <pre><code>import { useState, useEffect } from "react";

const Exemplo = () =&gt; {
  const [valor, setValor] = useState(0);
  useEffect(() =&gt; { /* efeito */ }, [valor]);
  return &lt;div&gt;{valor}&lt;/div&gt;;
};
</code></pre>
          </div>
        </div>
        <div class="card">
          <h3>Formulários, validação e UX</h3>
          <ul>
            <li><b>Inputs controlados</b>: mantenha o estado em React.</li>
            <li><b>Mensagens de erro</b>: feedback claro ao usuário (ex.: <code>antd/message</code>).</li>
            <li><b>Máscaras/formatadores</b>: use utilitários (ex.: formatar CNPJ).</li>
          </ul>
        </div>
      </section>

      <section id="nextjs-app">
        <h2>5. Next.js (App Router) <span class="level level-intermediate">Intermediário</span></h2>
        <div class="card">
          <h3>Estrutura de pastas principal</h3>
          <pre><code>src/
  app/
    page.tsx                  // página inicial
    layout.tsx                // layout raiz (metadata, favicon)
    dashboard/                // rotas aninhadas
      page.tsx
    api/                      // API Routes (route handlers)
      nfse/
        cancelar/route.ts     // exemplo de endpoint
</code></pre>
          <ul>
            <li><b>Server Components</b> por padrão no App Router.</li>
            <li>Para usar estados/efeitos do cliente, declare <code>"use client"</code> no topo do arquivo.</li>
          </ul>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>Metadata e favicon</h3>
            <pre><code>// layout.tsx
export const metadata = { title: "NFSe", icons: { icon: "/favicon/favicon.ico" } };
</code></pre>
          </div>
          <div class="card">
            <h3>Navegação</h3>
            <pre><code>import Link from "next/link";
import { useRouter } from "next/navigation";

// Link para outra página
&lt;Link href="/dashboard"&gt;Abrir&lt;/Link&gt;

// Navegação programática
const router = useRouter();
// router.push("/servicos");
</code></pre>
          </div>
        </div>
      </section>

      <section id="estilizacao-ui">
        <h2>6. Estilização e UI <span class="level level-basic">Básico</span></h2>
        <div class="two-col">
          <div class="card">
            <h3>Tailwind CSS</h3>
            <pre><code>&lt;div className="p-4 rounded-md border border-gray-300"&gt;Caixa&lt;/div&gt;
</code></pre>
          </div>
          <div class="card">
            <h3>Ant Design e outros</h3>
            <pre><code>import { Modal, message } from "antd";
import Select from "react-select";
</code></pre>
            <ul>
              <li>Use componentes do AntD para diálogos, feedback e formulários.</li>
              <li><code>react-select</code> para selects ricos com busca.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="estado-contexto">
        <h2>7. Estado global e Context <span class="level level-intermediate">Intermediário</span></h2>
        <div class="card">
          <h3>AuthContext e outros</h3>
          <pre><code>// Exemplo simplificado de Context
import { createContext, useContext, useState } from "react";

type Auth = { token?: string; login: (t: string) =&gt; void; logout: () =&gt; void };
const AuthContext = createContext&lt;Auth | undefined&gt;(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [token, setToken] = useState&lt;string | undefined&gt;();
  const value = { token, login: setToken, logout: () =&gt; setToken(undefined) };
  return &lt;AuthContext.Provider value={value}&gt;{children}&lt;/AuthContext.Provider&gt;;
}

export const useAuth = () =&gt; {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("useAuth deve ser usado dentro do AuthProvider");
  return ctx;
};
</code></pre>
          <p class="muted">No projeto atual há Contexts para autenticação, certificado, prestador, etc.</p>
        </div>
      </section>

      <section id="api-routes">
        <h2>8. APIs do Next.js (Route Handlers) <span class="level level-intermediate">Intermediário</span></h2>
        <div class="card">
          <h3>Estrutura e tipagem</h3>
          <pre><code>// src/app/api/nfse/cancelar/route.ts (exemplo esquemático)
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    // validar body, autenticar, processar...
    return NextResponse.json({ ok: true });
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    return new NextResponse(msg, { status: 400 });
  }
}
</code></pre>
          <ul>
            <li>Valide entrada, converta números com vírgula/ponto quando preciso.</li>
            <li>Sempre trate erros e retorne mensagens claras.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Fetch interno e bibliotecas</h3>
          <ul>
            <li><b>Assinatura XML:</b> endpoint local <code>/api/nfse/assinar</code> usando certificado.</li>
            <li><b>Compactação:</b> <code>pako</code> (GZip) + Base64 para eventos.</li>
            <li><b>Segurança:</b> use cookies HTTP-only e verifique o token.</li>
          </ul>
        </div>
      </section>

      <section id="auth-jwt">
        <h2>9. Autenticação e JWT <span class="level level-advanced">Avançado</span></h2>
        <div class="card">
          <h3>Fluxo</h3>
          <ul>
            <li>Login na API: valida usuário/senha, gera JWT (biblioteca <code>jose</code>), grava cookie HTTP-only.</li>
            <li>Middleware protege rotas; páginas públicas como <code>/login</code> são liberadas.</li>
            <li>Context de autenticação lê estado e oferece <code>login/logout</code>.</li>
          </ul>
          <pre><code>// Geração de token (exemplo esquemático)
import { SignJWT } from "jose";
const token = await new SignJWT({ sub: user.id }).setProtectedHeader({ alg: "HS256" }).setExpirationTime("2h").sign(secret);
</code></pre>
        </div>
      </section>

      <section id="prisma-db">
        <h2>10. Prisma e Banco de Dados (MySQL) <span class="level level-intermediate">Intermediário</span></h2>
        <div class="card">
          <h3>Conceitos</h3>
          <ul>
            <li>Modelos em <code>prisma/schema.prisma</code>.</li>
            <li>Tipos gerados utilizados no backend e frontend.</li>
            <li>Seeds para dados iniciais e migrações versionadas.</li>
          </ul>
          <pre><code>// Consulta (exemplo)
import { prisma } from "@/lib/prisma";
const prestadores = await prisma.prestador.findMany({ where: { ativo: true } });
</code></pre>
        </div>
      </section>

      <section id="arquitetura-nfse">
        <h2>11. Arquitetura NFSe (no projeto) <span class="level level-advanced">Avançado</span></h2>
        <div class="card">
          <h3>Elementos usados</h3>
          <ul>
            <li>Montagem de XML do evento (ex.: cancelamento).</li>
            <li>Assinatura digital do XML com certificado local.</li>
            <li>Compactação GZip + Base64 antes do envio.</li>
            <li>Chamada de endpoints internos que fazem o proxy para serviços externos.</li>
          </ul>
          <pre><code>// Trecho (simplificado) do CancelarNfseModal
const gz = pako.gzip(xmlAssinado, { level: 9 });
const b64 = base64FromUint8(gz);
const resp = await fetch("/api/nfse/cancelar", { method: "POST", body: JSON.stringify({ pedidoRegistroEvento: { evento: b64 } }) });
</code></pre>
          <p class="muted">Mantenha logs e mensagens claras; valide chave de acesso (44/50 dígitos), motivo e justificativa.</p>
        </div>
      </section>

      <section id="tests">
        <h2>12. Testes (Cypress) <span class="level level-intermediate">Intermediário</span></h2>
        <div class="card">
          <h3>Estratégia do projeto</h3>
          <ul>
            <li>Testes E2E em <code>cypress/e2e</code> com comandos customizados em <code>cypress/support/commands.ts</code>.</li>
            <li>Fixtures em <code>cypress/fixtures</code> para dados de formulário.</li>
            <li>Scripts PowerShell prontos para execução controlada no Windows.</li>
            <li>Arquivos em UTF-8 e sem BOM; cuidado com acentos.</li>
          </ul>
          <pre><code>// Comandos customizados (exemplo)
Cypress.Commands.add("fazerLogin", (...) =&gt; { /* ... */ });
Cypress.Commands.add("irPara", (rota) =&gt; { /* ... */ });
Cypress.Commands.add("verificarTitulo", (titulo) =&gt; { /* ... */ });
</code></pre>
        </div>
      </section>

      <section id="boas-praticas">
        <h2>13. Boas práticas e clean code <span class="level level-all">Todos</span></h2>
        <div class="card">
          <ul>
            <li><b>Nomes claros</b> para variáveis, funções e componentes.</li>
            <li><b>Funções pequenas</b>, coesas, com um único propósito.</li>
            <li><b>Tratamento de erros</b> padronizado com mensagens úteis.</li>
            <li><b>Tipagem explícita</b> e sem <code>any</code> (a menos que inevitável).</li>
            <li><b>Separação de responsabilidades</b>: serviços, componentes, APIs, contexto.</li>
            <li><b>Formatação numérica</b> e de documentos (CNPJ/IM) via utilitários.</li>
            <li><b>UTF-8</b> em todos os arquivos fonte.</li>
          </ul>
        </div>
      </section>

      <section id="troubleshooting">
        <h2>14. Troubleshooting <span class="level level-all">Todos</span></h2>
        <div class="card">
          <ul>
            <li><b>Problemas de acentuação</b>: garantir arquivos como UTF-8 sem BOM.</li>
            <li><b>Falhas de tipagem</b>: revisar tipos do Prisma e interfaces locais.</li>
            <li><b>Assinatura XML</b>: conferir ID da tag assinada e posição de <code>&lt;Signature&gt;</code>.</li>
            <li><b>APIs</b>: verificar tratamento de erros com <code>NextResponse</code> e logs.</li>
            <li><b>Testes E2E</b>: garantir seletores estáveis e fixtures consistentes.</li>
          </ul>
        </div>
      </section>

      <section id="react-do-zero">
        <h2>15. Front-end React do Zero (Prático e Responsivo) <span class="level level-basic">Básico</span></h2>
        <div class="card">
          <h3>1) Mentalidade: pensar em componentes</h3>
          <ul>
            <li><b>Divida a interface</b> em blocos reutilizáveis (botões, inputs, cards, tabelas).</li>
            <li><b>Dados entram por props</b>, interações disparam callbacks; evite estado global sem necessidade.</li>
            <li><b>Top-down</b>: comece por uma tela simples, depois quebre em peças menores.</li>
          </ul>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>2) Componentes e Props (do zero)</h3>
            <pre><code>type TituloProps = { texto: string; destaque?: boolean };
export function Titulo({ texto, destaque = false }: TituloProps) {
  return (
    &lt;h1 className={destaque ? "text-2xl text-blue-400" : "text-2xl"}&gt;
      {texto}
    &lt;/h1&gt;
  );
}

// Uso
&lt;Titulo texto="Serviços" destaque /&gt;
</code></pre>
          </div>
          <div class="card">
            <h3>3) Estado local e eventos</h3>
            <pre><code>import { useState } from "react";

export function Contador() {
  const [valor, setValor] = useState(0);
  return (
    &lt;div className="flex items-center gap-2"&gt;
      &lt;button onClick={() =&gt; setValor(v =&gt; v - 1)} className="px-2 border"&gt;-&lt;/button&gt;
      &lt;span&gt;{valor}&lt;/span&gt;
      &lt;button onClick={() =&gt; setValor(v =&gt; v + 1)} className="px-2 border"&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
          </div>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>4) Formulários controlados</h3>
            <pre><code>type Cliente = { nome: string; email: string };
export function FormCliente({ onSubmit }: { onSubmit: (c: Cliente) =&gt; void }) {
  const [form, setForm] = useState&lt;Cliente&gt;({ nome: "", email: "" });
  function alterar(k: keyof Cliente, v: string) { setForm({ ...form, [k]: v }); }
  return (
    &lt;form onSubmit={e =&gt; { e.preventDefault(); onSubmit(form); }} className="space-y-2"&gt;
      &lt;input value={form.nome} onChange={e =&gt; alterar("nome", e.target.value)} className="border p-2 w-full" placeholder="Nome" /&gt;
      &lt;input value={form.email} onChange={e =&gt; alterar("email", e.target.value)} className="border p-2 w-full" placeholder="Email" /&gt;
      &lt;button className="bg-blue-600 text-white px-3 py-1 rounded"&gt;Salvar&lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
          </div>
          <div class="card">
            <h3>5) Composição e children</h3>
            <pre><code>type CardProps = { titulo: string; children: React.ReactNode };
export function Card({ titulo, children }: CardProps) {
  return (
    &lt;div className="border rounded p-3"&gt;
      &lt;div className="font-semibold mb-2"&gt;{titulo}&lt;/div&gt;
      {children}
    &lt;/div&gt;
  );
}

// Uso
&lt;Card titulo="Resumo"&gt;
  &lt;p&gt;Conteúdo livre aqui.&lt;/p&gt;
&lt;/Card&gt;
</code></pre>
          </div>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>6) Responsividade com Tailwind (grid/flex)</h3>
            <pre><code>// Grid simples 1-2 colunas
&lt;div className="grid grid-cols-1 md:grid-cols-2 gap-4"&gt;
  &lt;div className="p-4 border rounded"&gt;A&lt;/div&gt;
  &lt;div className="p-4 border rounded"&gt;B&lt;/div&gt;
&lt;/div&gt;

// Barra responsiva
&lt;div className="flex flex-col md:flex-row items-stretch md:items-center gap-2"&gt;
  &lt;input className="border p-2 flex-1" placeholder="Buscar" /&gt;
  &lt;button className="bg-green-600 text-white px-3 py-2 rounded"&gt;Filtrar&lt;/button&gt;
&lt;/div&gt;
</code></pre>
          </div>
          <div class="card">
            <h3>7) Acessibilidade básica</h3>
            <ul>
              <li>Use rótulos e <code>aria-*</code> quando necessário (ex.: modais, diálogos).</li>
              <li>Botões reais para ações, não apenas &lt;div&gt; clicável.</li>
              <li>Foco visível, contraste adequado, textos alternativos em imagens.</li>
            </ul>
          </div>
        </div>
        <div class="two-col">
          <div class="card">
            <h3>8) Comunicação com a API</h3>
            <pre><code>async function getServicos() {
  const r = await fetch("/api/servicos", { method: "GET" });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

export function ListaServicos() {
  const [dados, setDados] = useState&lt;any[]&gt;([]);
  const [erro, setErro] = useState&lt;string | undefined&gt;();
  useEffect(() =&gt; { getServicos().then(setDados).catch(e =&gt; setErro(String(e))); }, []);
  if (erro) return &lt;div className="text-red-400"&gt;{erro}&lt;/div&gt;;
  return (
    &lt;ul className="list-disc pl-5"&gt;
      {dados.map(s =&gt; &lt;li key={s.id}&gt;{s.descricao}&lt;/li&gt;)}
    &lt;/ul&gt;
  );
}
</code></pre>
          </div>
          <div class="card">
            <h3>9) Performance e boas práticas</h3>
            <ul>
              <li>Evite recriar objetos/funções sem necessidade (useMemo/useCallback quando fizer diferença).</li>
              <li>Quebre componentes grandes; extraia listas e itens em componentes menores.</li>
              <li>Evite múltiplos <code>setState</code> sequenciais desnecessários.</li>
            </ul>
          </div>
        </div>
        <div class="card">
          <h3>10) Roteiro de estudo prático (exercícios)</h3>
          <ol>
            <li><b>Componente de lista</b>: renderize uma lista de objetos com chave, filtro por texto e ordenação.</li>
            <li><b>Formulário controlado</b>: crie, valide campos obrigatórios e mostre mensagens de erro.</li>
            <li><b>Layout responsivo</b>: transforme uma tela em grid responsivo (1 → 2 colunas).</li>
            <li><b>Integração com API</b>: faça GET/POST em uma rota local e trate erros.</li>
            <li><b>Refatoração</b>: extraia subcomponentes e deixe o componente pai mais limpo.</li>
          </ol>
        </div>
        <div class="card">
          <h3>11) Checklist de revisão (visão crítica)</h3>
          <ul>
            <li>Nomes de componentes/props claros e coesos?</li>
            <li>Estado mínimo e bem localizado? (evite global sem necessidade)</li>
            <li>Responsividade funcional (mobile primeiro) sem overflow lateral?</li>
            <li>Erros tratados e mensagens amigáveis ao usuário?</li>
            <li>Sem <code>any</code> desnecessário; tipos bem definidos?</li>
          </ul>
        </div>
      </section>

      <section id="projetos-praticos">
        <h2>16. Projetos práticos guiados</h2>
        <div class="card">
          <h3>Projeto 1: Lista + Filtro + API</h3>
          <ol>
            <li>Crie um componente de busca (input controlado) e uma lista renderizada por map.</li>
            <li>Implemente filtro textual e ordenação asc/desc.</li>
            <li>Crie rota GET em <code>/api/exemplos</code> e consuma com <code>fetch</code>.</li>
            <li>Deixe responsivo (1 coluna → 2 colunas ≥ md) com Tailwind.</li>
          </ol>
        </div>
        <div class="card">
          <h3>Projeto 2: Formulário completo</h3>
          <ol>
            <li>Monte um formulário controlado com validação (campos obrigatórios e formatos).</li>
            <li>POST para <code>/api/exemplos</code> e trate erros no frontend (mensagens amigáveis).</li>
            <li>Mostre um resumo do item salvo em um card (composição e children).</li>
            <li>Inclua testes E2E simples no Cypress (preencher e validar).</li>
          </ol>
        </div>
        <div class="card">
          <h3>Projeto 3: Mini dashboard autenticado</h3>
          <ol>
            <li>Crie login com cookie HTTP-only (APIs do Next + jose) e middleware protegendo rotas.</li>
            <li>Use Context para manter estado do usuário e botão de logout.</li>
            <li>Liste dados no dashboard a partir de uma rota autenticada.</li>
            <li>Adicione skeleton loading e feedback de erro.</li>
          </ol>
        </div>
        <div class="card">
          <h3>Dicas finais</h3>
          <ul>
            <li>Versões pequenas e incrementais (commit por passo).</li>
            <li>Nomeie bem props e estados; mantenha componentes coesos.</li>
            <li>Use o checklist da seção React do Zero para revisão final.</li>
          </ul>
        </div>
      </section>

      <section id="referencias">
        <h2>15. Referências</h2>
        <div class="card">
          <ul>
            <li><a href="https://www.typescriptlang.org/" target="_blank" rel="noreferrer">TypeScript</a></li>
            <li><a href="https://react.dev/" target="_blank" rel="noreferrer">React</a></li>
            <li><a href="https://nextjs.org/docs/app" target="_blank" rel="noreferrer">Next.js App Router</a></li>
            <li><a href="https://www.prisma.io/docs" target="_blank" rel="noreferrer">Prisma</a></li>
            <li><a href="https://ant.design/components/overview/" target="_blank" rel="noreferrer">Ant Design</a></li>
            <li><a href="https://tailwindcss.com/docs" target="_blank" rel="noreferrer">Tailwind CSS</a></li>
            <li><a href="https://docs.cypress.io/" target="_blank" rel="noreferrer">Cypress</a></li>
          </ul>
          <p class="muted">Consulte também a pasta <code>public/docs</code> do projeto para materiais específicos, como manuais e fluxogramas.</p>
        </div>
      </section>

      <p class="muted">Manual em HTML – compatível com Windows/PowerShell. Nenhum comando de build/dev é executado por aqui.</p>
    </main>
  </div>
  <script>
    (function () {
      const btn = document.getElementById('tocBtn');
      const side = document.getElementById('sideNav');
      if (btn && side) {
        btn.addEventListener('click', function () {
          side.classList.toggle('toc-open');
        });
      }
      // Fechar o TOC ao clicar em um link (em telas pequenas)
      const links = document.querySelectorAll('#toc a');
      links.forEach(function (a) {
        a.addEventListener('click', function () {
          if (window.matchMedia('(max-width: 1024px)').matches) {
            side.classList.remove('toc-open');
          }
        });
      });
    })();
  </script>
</body>
</html>
